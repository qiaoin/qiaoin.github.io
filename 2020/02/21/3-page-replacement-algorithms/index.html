<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.82.0" />


<title>页面置换算法 - 在桥边</title>
<meta property="og:title" content="页面置换算法 - 在桥边">


  <link href='https://qiaoin.github.io/favicon.ico' rel='icon' type='image/x-icon'/>



  







<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">
<link rel="stylesheet" href="/css/bootstrap-table.css">

<link rel="stylesheet" href="/css/custom.css">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/re-learning-cs/">重学基础</a></li>
    
    <li><a href="/readings/">Readings</a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/qiaoin">GitHub</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    

    <h1 class="article-title">页面置换算法</h1>

    
    <span class="article-date">2020-02-21</span>
    

    <div class="article-content">
      <blockquote>
<p>重学操作系统系列，清华大学操作系统课程笔记</p>
</blockquote>
<hr>
<div class="toc">
    <details>
        <summary>Table of contents</summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#页面置换算法的概念">页面置换算法的概念</a></li>
    <li><a href="#局部置换算法">局部置换算法</a>
      <ul>
        <li><a href="#最优页面置换算法optoptimal">最优页面置换算法（OPT，optimal）</a></li>
        <li><a href="#先进先出算法fifofirst-in-first-out">先进先出算法（FIFO，First-In First-Out）</a></li>
        <li><a href="#最近最久未使用算法lruleast-recently-used">最近最久未使用算法（LRU，Least Recently Used）</a></li>
        <li><a href="#时钟页面置换算法clock">时钟页面置换算法（Clock）</a></li>
        <li><a href="#最不常用算法lfuleast-frequently-used">最不常用算法（LFU，Least Frequently Used）</a></li>
        <li><a href="#belady-现象">Belady 现象</a></li>
        <li><a href="#比较">比较</a></li>
      </ul>
    </li>
    <li><a href="#全局页面置换算法">全局页面置换算法</a>
      <ul>
        <li><a href="#cpu-利用率与并发进程数的关系">CPU 利用率与并发进程数的关系</a></li>
        <li><a href="#工作集置换算法">工作集置换算法</a></li>
        <li><a href="#缺页率置换算法">缺页率置换算法</a></li>
        <li><a href="#抖动thrashing">抖动（thrashing）</a></li>
        <li><a href="#负载控制">负载控制</a></li>
      </ul>
    </li>
    <li><a href="#版权声明">版权声明</a></li>
  </ul>
</nav>
    </details>
</div>
<hr>
<h2 id="页面置换算法的概念">页面置换算法的概念</h2>
<p><strong>功能：</strong></p>
<p>当出现缺页异常，需调入新页面而物理内存已满时，置换算法选择被置换的物理页帧</p>
<p><strong>设计目标：</strong></p>
<p>尽可能减少页帧的调入调出次数，把未来不再访问或短期内不访问的页帧调出。这与实际运行的程序对存储的访问特征有很大关系（通用置换算法考虑可能得进程访问存储的特征）。如何对未来的情况进行估计呢？</p>
<p>有一些物理页帧被锁定（Frame Locking，pin memory），不能够从物理内存中换出到外存中去</p>
<ul>
<li>描述必须常驻内存的逻辑页面</li>
<li>操作系统的关键部分</li>
<li>要求响应速度的代码和数据</li>
<li>页表项中的锁定标志位（lock bit）</li>
</ul>
<p><strong>置换算法的评价方法：</strong></p>
<p>记录进程访问内存的页面轨迹，模拟页面置换行为，记录产生缺页的次数。更少的缺页，对应更好的性能</p>
<p><strong>页面置换算法的分类：</strong></p>
<ol>
<li>局部页面置换算法：置换页面的选择范围仅限于当前进程占用的物理页面内
<ul>
<li>最优算法、先进先出算法、最近最久未使用算法</li>
<li>时钟算法、最不常用算法（两种对最近最久未使用算法的近似）</li>
</ul>
</li>
<li>全局页面置换算法：置换页面的选择范围是所有可换出的物理页面
<ul>
<li>工作集算法、缺页率算法</li>
</ul>
</li>
</ol>
<h2 id="局部置换算法">局部置换算法</h2>
<p>假定给一个进程的物理页面数已经确定好了</p>
<h3 id="最优页面置换算法optoptimal">最优页面置换算法（OPT，optimal）</h3>
<ul>
<li>思路：置换在未来最长时间不访问的页面</li>
<li>实现：缺页时，计算内存中每个逻辑页面的下一次访问时间，选择未来最长时间不放问的页面</li>
<li>特征
<ul>
<li>缺页最少，是理想情况</li>
<li>实际系统中无法实现</li>
<li>无法预知每个页面在下次访问前的等待时间</li>
<li>可以作为其他置换算法的性能评价依据：在模拟器上运行某个程序并记录每一次的页面访问情况；在第二次运行时使用最优页面置换算法</li>
</ul>
</li>
</ul>
<h3 id="先进先出算法fifofirst-in-first-out">先进先出算法（FIFO，First-In First-Out）</h3>
<ul>
<li>思路：选择在内存驻留时间最长的页面进行置换</li>
<li>实现
<ul>
<li>维护一个记录所有位于内存中的逻辑页面链表</li>
<li>链表元素按驻留内存的时间排序，链首最长，链尾最短</li>
<li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li>
</ul>
</li>
<li>特征
<ul>
<li>实现简单</li>
<li>性能较差，调出的页面可能是经常访问的</li>
<li>进程分配物理页面数增加时，缺页并不一定减少（Belady 现象）</li>
<li>很少单独使用</li>
</ul>
</li>
</ul>
<h3 id="最近最久未使用算法lruleast-recently-used">最近最久未使用算法（LRU，Least Recently Used）</h3>
<ul>
<li>思路：选择最长时间没有被引用的页面进行置换，如某些页面长时间未被访问，则它们在将来还可能会长时间不会被访问</li>
<li>实现
<ul>
<li>缺页时，计算内存中每个逻辑页面的上一次访问时间</li>
<li>选择上一次使用到当前时间最长的页面</li>
</ul>
</li>
<li>特征：最优置换算法的一种近似，开销较大</li>
<li>可能实现：
<ul>
<li>
<ol>
<li>页面链表：系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面</li>
</ol>
<ul>
<li>访问内存时，找到相应页面，并把它移到链表首部</li>
<li>缺页时，置换链表尾节点的页面</li>
</ul>
</li>
<li>
<ol start="2">
<li>活动页面栈</li>
</ol>
<ul>
<li>访问页面时，将此页号压入栈顶，并栈内相同的页号抽出</li>
<li>缺页时，置换栈底的页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="时钟页面置换算法clock">时钟页面置换算法（Clock）</h3>
<ul>
<li>思路
<ul>
<li>仅对页面的访问情况进行大致排序</li>
</ul>
</li>
<li>数据结构
<ul>
<li>在页表项中增加访问位，描述页面在过去一段时间内的访问情况</li>
<li>各页面组织成环形链表</li>
<li>指针指向最先调入的页面</li>
</ul>
</li>
<li>算法
<ul>
<li>访问页面时，在页表项记录页面的访问情况</li>
<li>缺页时，从指针处开始顺序查找未被访问的页面进行置换（FIFO）</li>
</ul>
</li>
<li>特征
<ul>
<li>时钟算法是 LRU 和 FIFO 的折中（对过去的访问情况有考虑，但是置换的就是过去一段时间没有访问的页面，不是去找最久未访问的页面）</li>
</ul>
</li>
<li>实现：
<ul>
<li>页面装入内存时，访问位初始化为 0；访问页面（读/写）时，访问位设置为 1</li>
<li>缺页时，从指针当前位置顺序检查环形链表，若访问位为 0，则置换该页；若访问位为 1，则将访问位设置为 0（表示从当前时间点重新开始记录是否访问），并指针移动到下一个页面，直到找到可置换的页面</li>
</ul>
</li>
<li>改进的时钟算法
<ul>
<li>思路是减少修改页的缺页处理开销（如果有修改，则跳过这一页不做置换，系统定期将修改过的页写到外存中去）。</li>
<li>在页表项中增加修改位，并在访问时进行相应修改（如果是读操作，仅修改访问位为1，修改位为 0；如果是写操作，修改位和访问位同时置 1）</li>
<li>缺页时，修改页表项标志位，以跳过有修改的页面</li>
</ul>
</li>
</ul>
<p><img src="images/dirty-reference-bit.png" alt="dirty-reference-bit"></p>
<h3 id="最不常用算法lfuleast-frequently-used">最不常用算法（LFU，Least Frequently Used）</h3>
<ul>
<li>思路：缺页时，置换访问次数最少的页面</li>
<li>实现
<ul>
<li>每个页面设置一个访问计数</li>
<li>访问页面时，访问计数加 1</li>
<li>缺页时，置换计数最小的页面</li>
</ul>
</li>
<li>特征
<ul>
<li>算法开销大</li>
<li>开始时频繁使用，但以后不使用的页面很难置换（解决办法：计数定期做衰减右移）</li>
</ul>
</li>
<li>LRU 和 LFU 的区别
<ul>
<li>LRU 关注多久未访问，时间越短越好</li>
<li>LFU 关注访问次数，次数越多越好</li>
</ul>
</li>
</ul>
<h3 id="belady-现象">Belady 现象</h3>
<ul>
<li>现象：采用 FIFO 等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象</li>
<li>原因：FIFO 算法的置换特征与进程访问内存的动态特征相矛盾，被算法置换出去的页面并不一定是进程近期不会访问的</li>
<li>思考：哪些置换算法没有 Belady 现象？LRU 没有 Belady 现象</li>
<li>时钟/改进的时钟页面置换算法是否有 Belady 现象？</li>
<li>为什么 LRU 页面置换算法没有 Belady 现象？【思考？】</li>
</ul>
<h3 id="比较">比较</h3>
<ul>
<li>LRU 算法和 FIFO 本质上都是先进先出的思想
<ul>
<li>LRU 根据页面的最近访问时间排序</li>
<li>LRU 在执行过程中需要动态地调整顺序</li>
<li>FIFO 依据页面进入内存的时间排序</li>
<li>FIFO 的页面进入时间是固定不变的</li>
</ul>
</li>
<li>LRU 可退化为 FIFO
<ul>
<li>如页面进入内存后就没有被访问，最近访问时间和进入内存时间是相同的（视频流）</li>
</ul>
</li>
<li>LRU 算法性能好，但系统开销较大</li>
<li>FIFO 算法系统开销较小，会发生 Belady 现象</li>
<li>Clock 算法是 LRU 和 FIFO 的折中
<ul>
<li>访问页面时，不动态调整页面在链表中的顺序，仅做标记</li>
<li>缺页时，再把它移动到链表末尾</li>
</ul>
</li>
<li>对于未访问过的页面，Clock 和 LRU 算法的表现一样好</li>
<li>对于被访问过的页面，Clock 算法不能记录准确访问顺序，而 LRU 算法可以</li>
</ul>
<h2 id="全局页面置换算法">全局页面置换算法</h2>
<p>局部页面置换算法没有考虑进程访存的差异性（因为分配给进程的页面数确定了）</p>
<p>全局置换算法为进程分配可变数目的物理页面。那分给各个进程多少物理页面呢？进程在不同阶段的内存需求是变化的，这样再不同的阶段分配给进程的内存也需要有所变化。全局置换算法需要确定分配给进程的物理页面数</p>
<h3 id="cpu-利用率与并发进程数的关系">CPU 利用率与并发进程数的关系</h3>
<p>CPU 利用率与并发进程数存在相互促进和制约的关系</p>
<ul>
<li>进程数少时，提高并发进程数，可提高 CPU 利用率</li>
<li>并发进程导致内存访问增加</li>
<li>并发进程的内存访问会降低访存的局部性特征</li>
<li>局部性特征的下载会导致缺页率上升和 CPU 利用率下降</li>
</ul>
<p><img src="images/prognum-cpu-utility.png" alt="prognum-cpu-utility"></p>
<h3 id="工作集置换算法">工作集置换算法</h3>
<p>一个进程当前正在使用的逻辑页面集合，可表示为二元函数 W(t, <code>$\Delta$</code>)</p>
<ul>
<li>t 是当前的执行时刻</li>
<li><code>$\Delta$</code> 称为工作集窗口（working-set window），即一个定长的页面访问时间窗口</li>
<li>W(t, <code>$\Delta$</code>) 是指在当前时刻 t 前的 <code>$\Delta$</code> 时间窗口中的所有访问页面所组成的集合</li>
<li>|W(t, <code>$\Delta$</code>)| 指工作集的大小，即页面数目</li>
</ul>
<p>一个进程的工作集的大小随着进程执行时间的变化而变化：</p>
<p><img src="images/working-set-size.png" alt="working-set-size"></p>
<ol>
<li>进程开始执行后，随着访问新页面逐步建立较稳定的工作集</li>
<li>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定</li>
<li>局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</li>
</ol>
<p><strong>常驻集：</strong></p>
<p>在当前时刻，进程实际驻留在内存当中的页面集合</p>
<p><strong>工作集与常驻集的关系：</strong></p>
<ul>
<li>工作集是进程在运行过程中的固有性质</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法</li>
</ul>
<p><strong>缺页率和常驻集的关系：</strong></p>
<ul>
<li>如果常驻集包含了工作集，缺页较少</li>
<li>工作集发生剧烈变动（过渡）时，缺页较多</li>
<li>进程常驻集大小达到一定数目后，缺页率也不会明显下降</li>
</ul>
<p><strong>工作集置换算法：</strong></p>
<ul>
<li>思路：换出不在工作集的页面</li>
<li>窗口大小 𝞽，当前时刻前 𝞽 各内存访问的页引用是工作集，被称为窗口大小</li>
<li>实现方法（开销大）
<ul>
<li>访存链表：链表用于维护窗口内的访存页面</li>
<li>访存时，换出不在工作集的页面；更新访存链表</li>
<li>缺页时，换入页面；更新访存链表</li>
</ul>
</li>
</ul>
<h3 id="缺页率置换算法">缺页率置换算法</h3>
<p>根据缺页之间的间隔来调整将哪些页面放到内存中，哪些页面需要被置换出去</p>
<p><strong>缺页率（page fault rate）：</strong></p>
<p>通常情况下，我们理解的缺页率是缺页的次数和访存次数之间的比值（缺页平均时间间隔的倒数）。影响缺页率的因素有：</p>
<ol>
<li>页面置换算法</li>
<li>分配给进程的物理页面数</li>
<li>页面大小</li>
<li>程序的编写方法</li>
</ol>
<p><strong>缺页率置换算法（PFF，Page Fault Frequency）：</strong></p>
<p>通过调节常驻集大小，使得每个进程的缺页率保持在一个合理的范围内</p>
<p><img src="images/page-fault-rate.png" alt="page-fault-rate"></p>
<ol>
<li>若进程缺页率过高，则增加常驻集以分配更多的物理页面</li>
<li>若进程缺页率过低，则减少常驻集以较少它的物理页面数</li>
</ol>
<p><strong>实现：</strong></p>
<ul>
<li>访存时，设置引用位标志</li>
<li>缺页时，计算从上次缺页时间 <code>$t_{last}$</code> 到现在 <code>$t_{current}$</code> 的时间间隔</li>
<li>如果 <code>$t_{current} - t_{last} &gt; T$</code>，则置换所有在 <code>$[t_{current}, t_{last}]$</code> 时间内没有被引用的页</li>
<li>如果  <code>$t_{current} - t_{last} &lt;= T$</code>，则增加缺失页到常驻集中</li>
<li>在工作集算法中，选择需要置换的页面是在访问时，开销比较大；在缺页率算法中，是在产生缺页中断时，会去考察缺页率是过低还是过高，将置换页面的操作放到缺页时来进行处理</li>
</ul>
<h3 id="抖动thrashing">抖动（thrashing）</h3>
<p>在系统中有多少个并发执行的进程在一起执行，对于系统来说是效率最高的</p>
<p>抖动是由于在系统中执行的进程数目过多，每个进程分配到的物理页面数太少，减少到一定程度，不能包含工作集，因此造成大量缺页，频繁置换，进程运行速度变慢。即随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。</p>
<p>操作系统需要在并发水平和缺页率之间达到一个平衡，选择一个适当的进程数目（调节并发进程数）和进程需要的物理页面数目（置换算法）</p>
<h3 id="负载控制">负载控制</h3>
<p>通过调节并发进程数（MPL，Multi-Programming Level）来进行系统负载控制</p>
<ul>
<li><code>$\Sigma WS_{i}$</code> = 内存大小</li>
<li>平均缺页间隔时间（MTBF，Mean Time Between Page Faults）</li>
<li>缺页异常处理时间（PFST，Page Fault Service Time）</li>
</ul>
<p><img src="images/load-balance.png" alt="load-balance"></p>
<p>目标：就整个系统处于均衡的繁忙状态</p>
<h2 id="版权声明">版权声明</h2>
<p>本作品采用<a href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接。</p>

    </div>
  </article>

  
<section class="comments">
<script src="https://utteranc.es/client.js"
        repo="qiaoin/hugo-blog-comments"
        issue-term="og:title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</section>



</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="https://qiaoin.github.io">在桥边</a> © 2016 - 2021
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    

    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EBLEJGMMQV"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-EBLEJGMMQV', { 'anonymize_ip': false });
}
</script>

  </body>
</html>


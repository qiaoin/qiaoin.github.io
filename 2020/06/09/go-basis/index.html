<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.82.0" />


<title>Go 语言基础 -- A Tour of Go - 在桥边</title>
<meta property="og:title" content="Go 语言基础 -- A Tour of Go - 在桥边">


  <link href='https://qiaoin.github.io/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/monokai.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">

<link rel="stylesheet" href="/css/custom.css">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/re-learning-cs/">重学基础</a></li>
    
    <li><a href="/readings/">Readings</a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/qiaoin">GitHub</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    

    <h1 class="article-title">Go 语言基础 -- A Tour of Go</h1>

    
    <span class="article-date">2020-06-09</span>
    

    <div class="article-content">
      <hr>
<div class="toc">
    <details>
        <summary>Table of contents</summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#环境搭建">环境搭建</a></li>
    <li><a href="#语言基础">语言基础</a>
      <ul>
        <li><a href="#packages-and-imports">Packages and Imports</a></li>
        <li><a href="#exported-names">Exported names</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#变量">变量</a></li>
        <li><a href="#常量">常量</a></li>
        <li><a href="#基础数据类型">基础数据类型</a></li>
        <li><a href="#数据类型转换">数据类型转换</a></li>
        <li><a href="#类型推导">类型推导</a></li>
        <li><a href="#for">for</a></li>
        <li><a href="#if">if</a></li>
        <li><a href="#switch">switch</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#指针">指针</a></li>
        <li><a href="#结构体-struct">结构体 struct</a></li>
        <li><a href="#数组">数组</a></li>
        <li><a href="#切片-slice">切片 slice</a></li>
        <li><a href="#映射字典-map">映射/字典 map</a></li>
        <li><a href="#函数值">函数值</a></li>
        <li><a href="#方法">方法</a></li>
        <li><a href="#接口">接口</a></li>
        <li><a href="#接口与隐式实现">接口与隐式实现</a></li>
        <li><a href="#接口值">接口值</a></li>
        <li><a href="#空接口">空接口</a></li>
        <li><a href="#类型断言">类型断言</a></li>
        <li><a href="#类型选择">类型选择</a></li>
        <li><a href="#strings">Strings</a></li>
        <li><a href="#错误">错误</a></li>
        <li><a href="#go-协程-goroutine">Go 协程 Goroutine</a></li>
        <li><a href="#信道-channel">信道 channel</a></li>
        <li><a href="#select">select</a></li>
        <li><a href="#等价二叉树">等价二叉树</a></li>
        <li><a href="#syncmutex">sync.Mutex</a></li>
        <li><a href="#web-爬虫">Web 爬虫</a></li>
      </ul>
    </li>
    <li><a href="#版权声明">版权声明</a></li>
  </ul>
</nav>
    </details>
</div>
<hr>
<h2 id="环境搭建">环境搭建</h2>
<p>按照 <a href="https://golang.org/doc/install">Getting Started</a> 进行安装，并设置好环境变量和创建好对应目录</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># go, for mit 6.824</span>
export GOPATH<span style="color:#f92672">=</span>$HOME/golang
export GOROOT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/usr/local/opt/go/libexec&#34;</span>
export PATH<span style="color:#f92672">=</span>$GOPATH/bin:$PATH
export PATH<span style="color:#f92672">=</span>$GOROOT/bin:$PATH
</code></pre></div><p><a href="https://golang.org/doc/code.html">How to Write Go Code</a></p>
<ul>
<li>模块组织</li>
<li>使用本地模块和远程模块</li>
<li>单元测试</li>
</ul>
<h2 id="语言基础">语言基础</h2>
<h3 id="packages-and-imports">Packages and Imports</h3>
<p>每个 Go 程序都是由 packages 组成，程序从 main package 开始运行</p>
<p>使用圆括号、分行引入多个 <code>import</code>，是更好的形式</p>
<h3 id="exported-names">Exported names</h3>
<blockquote>
<p>使用 C++ 中的 public、private 类比</p>
</blockquote>
<p>Go 语言中，属性和方法如果以大写字母开头，那么它就是 public 的；否则就是 private 的</p>
<p>当导入一个包时，我们可以引用 public 修饰的属性和方法，但访问不了 private 修饰的</p>
<h3 id="functions">Functions</h3>
<p>顺序：变量名 变量类型</p>
<p>当函数的两个或多个已命名形参的类型相同时，除最后一个类型意外，其它都可以省略</p>
<p>函数可以返回任意数量的返回值，即 tuple</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span>
}
</code></pre></div><p>Go 的函数返回值允许命名，它们会被视作定义在函数顶部的变量；没有参数的 <code>return</code> 语句返回已命名的返回值，也就是直接返回</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">split</span>(<span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">9</span>
    <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>
    <span style="color:#66d9ef">return</span>
}
</code></pre></div><h3 id="变量">变量</h3>
<p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p>
<p><code>var</code> 语句可以出现在包或函数级别</p>
<p>变量声明可以包含初始值，每个变量对应一个</p>
<p>如果初始值已存在，可以省略类型；变量会从初识值中获得类型</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">python</span>, <span style="color:#a6e22e">java</span> <span style="color:#66d9ef">bool</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> = <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#e6db74">&#34;no!&#34;</span>
</code></pre></div><p>使用 <code>var</code> 声明变量，但在函数中可以使用简洁赋值语句 <code>:=</code> 代替 <code>var</code> 声明</p>
<p>函数外的每行语句都必须以关键字开始（<code>var</code> <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用</p>
<p>同导入语句一样，变量声明也可以“分组”成一个语法块。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math/cmplx&#34;</span>
)

<span style="color:#66d9ef">var</span> (
    <span style="color:#a6e22e">ToBe</span>   <span style="color:#66d9ef">bool</span>       = <span style="color:#66d9ef">false</span>
    <span style="color:#a6e22e">MaxInt</span> <span style="color:#66d9ef">uint64</span>     = <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#a6e22e">z</span>      <span style="color:#66d9ef">complex128</span> = <span style="color:#a6e22e">cmplx</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">12i</span>)
)
</code></pre></div><h3 id="常量">常量</h3>
<p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>
<p>常量可以是字符、字符串、布尔值或数值</p>
<p>常量不能用 <code>:=</code> 语法声明</p>
<h3 id="基础数据类型">基础数据类型</h3>
<p>Go 的基本类型有</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">int</span>  <span style="color:#66d9ef">int8</span>  <span style="color:#66d9ef">int16</span>  <span style="color:#66d9ef">int32</span>  <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">uint8</span> <span style="color:#66d9ef">uint16</span> <span style="color:#66d9ef">uint32</span> <span style="color:#66d9ef">uint64</span> <span style="color:#66d9ef">uintptr</span>

<span style="color:#66d9ef">byte</span> <span style="color:#75715e">// alias for uint8
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">rune</span> <span style="color:#75715e">// alias for int32
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// represents a Unicode code point, 代表一个 Unicode 的码点
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">float32</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">complex64</span> <span style="color:#66d9ef">complex128</span>
</code></pre></div><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>
<p>没有明确初始值的变量声明会被赋予它们的<strong>零值（zero value）</strong>：</p>
<ul>
<li>数字类型 <code>0</code></li>
<li>布尔类型 <code>false</code></li>
<li>字符串类型 <code>&quot;&quot;</code>（空字符串）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v %v %v %q\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">s</span>)
}
</code></pre></div><h3 id="数据类型转换">数据类型转换</h3>
<p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code></p>
<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要<strong>显式类型转换</strong></p>
<h3 id="类型推导">类型推导</h3>
<p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var</code> = 表达式语法），变量的类型由右值推导得出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3.142</span> <span style="color:#75715e">// 修改这里！
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;v is of type %T\n&#34;</span>, <span style="color:#a6e22e">v</span>)
}
</code></pre></div><h3 id="for">for</h3>
<p>Go 只有一种循环结构，<code>for</code> 循环。初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见</p>
<p>初始化语句和后置语句是可选的，此时可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sum</span>)

    <span style="color:#a6e22e">all</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">all</span> &lt; <span style="color:#ae81ff">1000</span>; {
        <span style="color:#a6e22e">all</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">all</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">all</span>)

    <span style="color:#a6e22e">all2</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">all2</span> &lt; <span style="color:#ae81ff">1000</span> {
        <span style="color:#a6e22e">all2</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">all2</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">all2</span>)

    <span style="color:#75715e">// 无限循环
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> {
    }
}
</code></pre></div><h3 id="if">if</h3>
<p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code>，而大括号 <code>{ }</code> 则是必须的</p>
<p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句；该语句声明的变量作用域仅在 <code>if</code> 之内</p>
<p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#f92672">-</span><span style="color:#a6e22e">x</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;i&#34;</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprint</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pow</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">lim</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>); <span style="color:#a6e22e">v</span> &lt; <span style="color:#a6e22e">lim</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%g &gt;= %g\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">lim</span>)
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lim</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

}
</code></pre></div><p>牛顿法求平方根</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IsEnough</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">guess</span>) &lt; <span style="color:#ae81ff">0.0000000000001</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Improve</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">-</span> (<span style="color:#a6e22e">guess</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">guess</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
    <span style="color:#a6e22e">guess</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.0</span>
    <span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">IsEnough</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span>) {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">guess</span>)
        <span style="color:#a6e22e">guess</span> = <span style="color:#a6e22e">Improve</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span>)
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">guess</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">2</span>))
}
</code></pre></div><h3 id="switch">switch</h3>
<ul>
<li>Go 只运行满足条件的 <code>case</code>，而非之后的所有的 <code>case</code>。实际上，Go 自动提供给了其他语言在 <code>case</code> 后面所需要的 <code>break</code> 语句</li>
<li>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止</li>
<li>Go 的 <code>switch</code> 的 <code>case</code> 无需为常量，且取值不必为整数</li>
</ul>
<p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> {
    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">f</span>():
}
</code></pre></div><p>在 <code>i==0</code> 时 <code>f</code> 不会被调用</p>
<p>没有条件的 <code>switch</code> 同 <code>switch true</code> 一样；这种形式能将一长串 <code>if-then-else</code> 写得更加清晰。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
    <span style="color:#66d9ef">switch</span> {
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Hour</span>() &lt; <span style="color:#ae81ff">12</span>:
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Good morning!&#34;</span>)
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Hour</span>() &lt; <span style="color:#ae81ff">17</span>:
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Good afternoon.&#34;</span>)
    <span style="color:#66d9ef">default</span>:
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Good evening.&#34;</span>)
    }
}
</code></pre></div><h3 id="defer">defer</h3>
<p><code>defer</code> 语句会将函数推迟到外层函数返回之后执行。推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p>
<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;counting&#34;</span>)

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
    }

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;done&#34;</span>)
}
</code></pre></div><h3 id="指针">指针</h3>
<p>Go 语言中也有指针，指针保存了值的内存地址。类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code></p>
<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针</p>
<p><code>*</code> 操作符表示指针指向的底层值</p>
<p>与 C 不同，Go 没有指针运算</p>
<h3 id="结构体-struct">结构体 struct</h3>
<ul>
<li>一个结构体（<code>struct</code>）就是一组字段（field）</li>
<li>结构体字段使用点号来访问</li>
<li>结构体字段可以通过结构体指针来访问。如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">X</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
    <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#ae81ff">4</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)

    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
    <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">X</span> = <span style="color:#ae81ff">9</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
}
</code></pre></div><ul>
<li>结构体文法通过直接列出字段的值来新分配一个结构体。</li>
<li>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</li>
<li>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">var</span> (
    <span style="color:#a6e22e">v1</span> = <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}  <span style="color:#75715e">// 创建一个 Vertex 类型的结构体
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v2</span> = <span style="color:#a6e22e">Vertex</span>{<span style="color:#a6e22e">X</span>: <span style="color:#ae81ff">1</span>}  <span style="color:#75715e">// Y:0 被隐式地赋予
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v3</span> = <span style="color:#a6e22e">Vertex</span>{}      <span style="color:#75715e">// X:0 Y:0
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">p</span>  = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>} <span style="color:#75715e">// 创建一个 *Vertex 类型的结构体（指针）
</span><span style="color:#75715e"></span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">v2</span>, <span style="color:#a6e22e">v3</span>)
}
</code></pre></div><h3 id="数组">数组</h3>
<p>类型 <code>[n]T</code> 表示拥有 n 个 <code>T</code> 类型的值的数组</p>
<p>数组的长度是其类型的一部分，因此数组不能改变大小</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;Hello&#34;</span>
    <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#e6db74">&#34;World&#34;</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>])
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)

    <span style="color:#a6e22e">primes</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">6</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">primes</span>)
}
</code></pre></div><h3 id="切片-slice">切片 slice</h3>
<p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// a[low : high]
</span><span style="color:#75715e">// 切片下界的默认值为 0，上界则是该切片的长度
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">primes</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">6</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>}

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">primes</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]  <span style="color:#75715e">// [3, 5, 7]
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

    <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">2</span>]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

    <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>:]
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}
</code></pre></div><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素</p>
<ul>
<li>切片并不存储任何数据，它只是描述了底层数组中的一段。</li>
<li>更改切片的元素会修改其底层数组中对应的元素。</li>
<li>与它共享底层数组的切片都会观测到这些修改。</li>
</ul>
<p>切片文法类似于没有长度的数组文法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 数组文法
</span><span style="color:#75715e"></span>[<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}

<span style="color:#75715e">// 会创建一个和上面相同的数组，然后构建一个引用了它的切片
</span><span style="color:#75715e"></span>[]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}
</code></pre></div><p>切片拥有<strong>长度</strong>和<strong>容量</strong></p>
<p>切片的<strong>长度</strong>就是它所包含的元素个数。</p>
<p>切片的<strong>容量</strong>是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>
<p>切片的默认值是 <code>nil</code>。<code>nil</code> 切片的长度和容量为 0 且没有底层数组。</p>
<p>切片可以用内建函数 <code>make</code> 来创建，这也是创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// len(a)=5
</span></code></pre></div><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>) <span style="color:#75715e">// len(b)=0, cap(b)=5
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>[:cap(<span style="color:#a6e22e">b</span>)]  <span style="color:#75715e">// len(b)=5, cap(b)=5
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">1</span>:]      <span style="color:#75715e">// len(b)=4, cap(b)=4
</span></code></pre></div><p>切片可包含任何类型，甚至包括其它的切片</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 创建一个井字板（经典游戏）
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">board</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">string</span>{
        []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>},
        []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>},
        []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>},
    }

    <span style="color:#75715e">// 两个玩家轮流打上 X 和 O
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;X&#34;</span>
    <span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;O&#34;</span>
    <span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;X&#34;</span>
    <span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;O&#34;</span>
    <span style="color:#a6e22e">board</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#e6db74">&#34;X&#34;</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">board</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s\n&#34;</span>, <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">board</span>[<span style="color:#a6e22e">i</span>], <span style="color:#e6db74">&#34; &#34;</span>))
    }
}
</code></pre></div><p>向切片追加元素：为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。内建函数的文档对此函数有详细的介绍。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> append(<span style="color:#a6e22e">s</span> []<span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">vs</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">T</span>) []<span style="color:#a6e22e">T</span>
</code></pre></div><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p>
<p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>
<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
<p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pow</span> = []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">64</span>, <span style="color:#ae81ff">128</span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;2**%d = %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
    }
}
</code></pre></div><p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span>
<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span>
</code></pre></div><p>若你只需要索引，忽略第二个变量即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">pow</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
        <span style="color:#a6e22e">pow</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> uint(<span style="color:#a6e22e">i</span>) <span style="color:#75715e">// == 2**i
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pow</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d\n&#34;</span>, <span style="color:#a6e22e">value</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pic</span>(<span style="color:#a6e22e">dx</span>, <span style="color:#a6e22e">dy</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">uint8</span> {
    <span style="color:#a6e22e">items</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">dy</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">dy</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">dx</span>)
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">dx</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = uint8(<span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">j</span>)
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">items</span>
}
</code></pre></div><h3 id="映射字典-map">映射/字典 map</h3>
<p>映射将键映射到值。映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。<code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<p>映射的文法与结构体相似，不过必须有键名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Lat</span>, <span style="color:#a6e22e">Long</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>{
    <span style="color:#e6db74">&#34;Bell Labs&#34;</span>: <span style="color:#a6e22e">Vertex</span>{
        <span style="color:#ae81ff">40.68433</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">74.39967</span>,
    },
    <span style="color:#e6db74">&#34;Google&#34;</span>: <span style="color:#a6e22e">Vertex</span>{
        <span style="color:#ae81ff">37.42202</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">122.08408</span>,
    },
}

<span style="color:#75715e">// 若顶级类型只是一个类型名，你可以在文法的元素中省略它。
</span><span style="color:#75715e">// var m = map[string]Vertex{
</span><span style="color:#75715e">//     &#34;Bell Labs&#34;: {40.68433, -74.39967},
</span><span style="color:#75715e">//     &#34;Google&#34;:    {37.42202, -122.08408},
</span><span style="color:#75715e">// }
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>)

    <span style="color:#a6e22e">n</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">Vertex</span>)
    <span style="color:#a6e22e">n</span>[<span style="color:#e6db74">&#34;Bell Labs&#34;</span>] = <span style="color:#a6e22e">Vertex</span>{
        <span style="color:#ae81ff">40.68433</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">74.39967</span>,
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span>[<span style="color:#e6db74">&#34;Bell Labs&#34;</span>])
}
</code></pre></div><p>在映射 <code>m</code> 中插入或修改元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">elem</span>
</code></pre></div><p>获取元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">elem</span> = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
</code></pre></div><p>删除元素：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">delete(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">key</span>)
</code></pre></div><p>通过双赋值检测某个键是否存在：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
</code></pre></div><ul>
<li>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code>；否则，<code>ok</code> 为 <code>false</code>。</li>
<li>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</li>
</ul>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>
<p>注 ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
</code></pre></div><p>实现简单的 WordCount</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;strings&#34;</span>
    <span style="color:#e6db74">&#34;golang.org/x/tour/wc&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WordCount</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">slices</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Fields</span>(<span style="color:#a6e22e">s</span>)
    <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slices</span> {
         <span style="color:#a6e22e">ret</span>[<span style="color:#a6e22e">value</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">wc</span>.<span style="color:#a6e22e">Test</span>(<span style="color:#a6e22e">WordCount</span>)
}
</code></pre></div><h3 id="函数值">函数值</h3>
<p>函数也是值。它们可以像其它值一样传递。函数值可以用作函数的参数或返回值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">compute</span>(<span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">hypot</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">y</span>)
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">hypot</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">12</span>))

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">compute</span>(<span style="color:#a6e22e">hypot</span>))
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">compute</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>))
}
</code></pre></div><p>Go 支持函数闭包，实现斐波拉切数列</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">// 返回一个“返回int的函数”
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>() <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
        <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fibonacci</span>()
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>())
    }
}
</code></pre></div><h3 id="方法">方法</h3>
<p>Go 没有类，但可以为结构体类型定义<strong>方法</strong>。方法就是一类带特殊的<strong>接收者</strong>参数的函数。方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>())
}
</code></pre></div><p>记住：方法只是个带接收者参数的函数。</p>
<p>也可以为非结构体类型声明方法。接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。</p>
<pre><code class="language-go{10}" data-lang="go{10}">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

func main() {
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
}
</code></pre><p>可以为指针接收者声明方法，这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。试着移除第 16 行 <code>Scale</code> 函数声明中的 <code>*</code>，观察此程序的行为如何变化。</p>
<p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的<strong>副本</strong>进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>
<pre><code class="language-go{16}" data-lang="go{16}">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

func main() {
    v := Vertex{3, 4}
    v.Scale(10)
    fmt.Println(v.Abs())
}
</code></pre><p>将 <code>Abs</code> 和 <code>Scale</code> 方法重写为函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>) <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Scale</span>(<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>, <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) {
    <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
    <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">f</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}
    <span style="color:#a6e22e">Scale</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">10</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">v</span>))
}
</code></pre></div><p>比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// 编译错误！
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ScaleFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#ae81ff">5</span>) <span style="color:#75715e">// OK
</span></code></pre></div><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Scale</span>(<span style="color:#ae81ff">10</span>) <span style="color:#75715e">// OK
</span></code></pre></div><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</p>
<p>同样的事情也发生在相反的方向。接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#a6e22e">v</span>))  <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">AbsFunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>)) <span style="color:#75715e">// 编译错误！
</span></code></pre></div><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Vertex</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Abs</span>()) <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Abs</span>()) <span style="color:#75715e">// OK
</span></code></pre></div><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p>
<p>使用指针接收者的原因有二：</p>
<ol>
<li>方法能够修改其接收者指向的值。</li>
<li>可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</li>
</ol>
<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>
<h3 id="接口">接口</h3>
<p><strong>接口类型</strong>是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Abser</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Abser</span>
    <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MyFloat</span>(<span style="color:#f92672">-</span><span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt2</span>)
    <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Vertex</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}

    <span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">f</span>  <span style="color:#75715e">// a MyFloat 实现了 Abser
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">a</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span> <span style="color:#75715e">// a *Vertex 实现了 Abser
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 下面一行，v 是一个 Vertex（而不是 *Vertex）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以没有实现 Abser。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a = v
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">Abs</span>())
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyFloat</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">MyFloat</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span> &lt; <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> float64(<span style="color:#f92672">-</span><span style="color:#a6e22e">f</span>)
    }
    <span style="color:#66d9ef">return</span> float64(<span style="color:#a6e22e">f</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Vertex</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Vertex</span>) <span style="color:#a6e22e">Abs</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Y</span>)
}
</code></pre></div><h3 id="接口与隐式实现">接口与隐式实现</h3>
<p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>
<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">I</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">S</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#75715e">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">M</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">S</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span> = <span style="color:#a6e22e">T</span>{<span style="color:#e6db74">&#34;hello&#34;</span>}
    <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()
}
</code></pre></div><h3 id="接口值">接口值</h3>
<p>接口也是值。它们可以像其它值一样传递。接口值可以用作函数的参数或返回值。</p>
<p>在内部，接口值可以看做包含值和具体类型的元组：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">(<span style="color:#a6e22e">value</span>, <span style="color:#66d9ef">type</span>)
</code></pre></div><p>接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p>
<p>即便接口内的具体值为 <code>nil</code>，方法仍然会被 <code>nil</code> 接收者调用。在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p>
<p>注意: 保存了 <code>nil</code> 具体值的接口其自身并不为 <code>nil</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">I</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">S</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">M</span>() {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&lt;nil&gt;&#34;</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">S</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">F</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">F</span>) <span style="color:#a6e22e">M</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>

    <span style="color:#a6e22e">i</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">T</span>{<span style="color:#e6db74">&#34;Hello&#34;</span>}
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
    <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>
    <span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">t</span>
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
    <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()

    <span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>)
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
    <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">M</span>()

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ii</span> <span style="color:#a6e22e">I</span>
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">ii</span>)
    <span style="color:#a6e22e">ii</span>.<span style="color:#a6e22e">M</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span> <span style="color:#a6e22e">I</span>) {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;(%v, %T)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
}
</code></pre></div><p><code>nil</code> 接口值既不保存值也不保存具体类型。为 <code>nil</code> 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个<strong>具体</strong>方法的类型。</p>
<h3 id="空接口">空接口</h3>
<p>指定了零个方法的接口值被称为<strong>空接口</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">interface</span>{}
</code></pre></div><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface{}</code> 的任意数量的参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)

    <span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">42</span>
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)

    <span style="color:#a6e22e">i</span> = <span style="color:#e6db74">&#34;hello&#34;</span>
    <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">describe</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}) {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;(%v, %T)\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
}
</code></pre></div><h3 id="类型断言">类型断言</h3>
<p><strong>类型断言</strong>提供了访问接口值底层具体值的方式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">T</span>)
</code></pre></div><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个 panic。</p>
<p>为了<strong>判断</strong>一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#a6e22e">T</span>)
</code></pre></div><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生 panic。</p>
<p>请注意这种语法和读取一个映射时的相同之处。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#e6db74">&#34;hello&#34;</span>

    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">string</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

    <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">string</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">ok</span>)

    <span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">float64</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">ok</span>)

    <span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">float64</span>) <span style="color:#75715e">// 报错(panic)
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>)
}
</code></pre></div><h3 id="类型选择">类型选择</h3>
<p><strong>类型选择</strong>是一种按顺序从几个类型断言中选择分支的结构。</p>
<p>类型选择与一般的 <code>switch</code> 语句相似，不过类型选择中的 <code>case</code> 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">T</span>:
    <span style="color:#75715e">// v 的类型为 T
</span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">S</span>:
    <span style="color:#75715e">// v 的类型为 S
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
    <span style="color:#75715e">// 没有匹配，v 与 i 的类型相同
</span><span style="color:#75715e"></span>}
</code></pre></div><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p>
<p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p>
<h3 id="strings">Strings</h3>
<p><code>fmt</code> 包中定义的 <code>Stringer</code> 是最普遍的接口之一。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Stringer</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span>
}
</code></pre></div><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Person</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%v (%v years)&#34;</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Age</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#e6db74">&#34;Arthur Dent&#34;</span>, <span style="color:#ae81ff">42</span>}
    <span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#e6db74">&#34;Zaphod Beeblebrox&#34;</span>, <span style="color:#ae81ff">9001</span>}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">z</span>)
}
</code></pre></div><h3 id="错误">错误</h3>
<p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">error</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>
}
</code></pre></div><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#e6db74">&#34;42&#34;</span>)
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;couldn&#39;t convert number: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
    <span style="color:#66d9ef">return</span>
}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Converted integer:&#34;</span>, <span style="color:#a6e22e">i</span>)
</code></pre></div><p><code>error</code> 为 <code>nil</code> 时表示成功；非 <code>nil</code> 的 <code>error</code> 表示失败。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;math&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ErrNegativeSqrt</span> <span style="color:#66d9ef">float64</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#a6e22e">ErrNegativeSqrt</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;cannot Sqrt negative number: %v&#34;</span>, float64(<span style="color:#a6e22e">e</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IsEnough</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Abs</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">guess</span>) &lt; <span style="color:#ae81ff">0.0000000000001</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Improve</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">-</span> (<span style="color:#a6e22e">guess</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">guess</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">guess</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) (<span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">error</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ErrNegativeSqrt</span>(<span style="color:#a6e22e">x</span>)
    }

    <span style="color:#a6e22e">guess</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.0</span>
    <span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">IsEnough</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span>) {
        <span style="color:#a6e22e">guess</span> = <span style="color:#a6e22e">Improve</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">guess</span>)
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">guess</span>, <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">2</span>))
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Sqrt</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>))
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;io&#34;</span>
    <span style="color:#e6db74">&#34;os&#34;</span>
    <span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rot13Reader</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rot13</span>(<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">byte</span> {
    <span style="color:#66d9ef">switch</span> {
    <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;M&#39;</span>) <span style="color:#f92672">||</span> (<span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;m&#39;</span>):
        <span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">13</span>;
    <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#39;M&#39;</span> &lt; <span style="color:#a6e22e">b</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;Z&#39;</span>) <span style="color:#f92672">||</span> (<span style="color:#e6db74">&#39;m&#39;</span> &lt; <span style="color:#a6e22e">b</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;z&#39;</span>):
        <span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">13</span>;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">reader</span> <span style="color:#a6e22e">rot13Reader</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
    <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>)

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">rot13</span>(<span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>])
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;Lbh penpxrq gur pbqr!&#34;</span>)
    <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rot13Reader</span>{<span style="color:#a6e22e">s</span>}
    <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">r</span>)
}
</code></pre></div><h3 id="go-协程-goroutine">Go 协程 Goroutine</h3>
<p>Go 协程（goroutine）是由 Go 运行时管理的轻量级线程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)
</code></pre></div><p>会启动一个新的 Go 协程并执行</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>)
</code></pre></div><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 协程中，而 <code>f</code> 的执行发生在新的 Go 协程中。</p>
<p>Go 协程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<code>sync</code> 包提供了这种能力，不过在 Go 中并不经常用到，一般使用 <code>channel</code> 进行同步。</p>
<h3 id="信道-channel">信道 channel</h3>
<p>channel 是带有类型的管道，可以通过 channel 操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>    <span style="color:#75715e">// 将 v 发送至信道 ch。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>  <span style="color:#75715e">// 从 ch 接收值并赋予 v。
</span></code></pre></div><p>（“箭头”就是数据流的方向。）</p>
<p>和映射与切片一样，channel 在使用前必须创建：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</code></pre></div><p>默认情况下，<strong>发送和接收操作在另一端准备好之前都会阻塞</strong>。这使得 Go 协程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">v</span>
    }
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">sum</span> <span style="color:#75715e">// 将和送入 c
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>}

    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">s</span>[:len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">c</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">s</span>[len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>:], <span style="color:#a6e22e">c</span>)
    <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>, <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span> <span style="color:#75715e">// 从 c 中接收
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>)
}
</code></pre></div><p>channel 可以是<strong>带缓冲的</strong>，将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)
</code></pre></div><p>仅当 channel 的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>
<p>发送者可通过 <code>close</code> 关闭一个 channel 来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试 channel 是否被关闭：若没有值可以接收且 channel 已被关闭，那么在执行完</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
</code></pre></div><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>循环 <code>for i := range c</code> 会不断从 channel 接收值，直到它被关闭。</p>
<p><strong>注意</strong>：只有发送者才能关闭 channel，而接收者不能。向一个已经关闭的 channel 发送数据会引发程序 panic。</p>
<p><strong>还要注意</strong>：channel 与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>
        <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
    }
    close(<span style="color:#a6e22e">c</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fibonacci</span>(cap(<span style="color:#a6e22e">c</span>), <span style="color:#a6e22e">c</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
    }
}
</code></pre></div><h3 id="select">select</h3>
<p><code>select</code> 语句使一个 Go 协程可以等待多个通信操作。<code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">quit</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> {
        <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">x</span>:
            <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">quit</span>:
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;quit&#34;</span>)
            <span style="color:#66d9ef">return</span>
        }
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
    <span style="color:#a6e22e">quit</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>)
        }
        <span style="color:#a6e22e">quit</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
    }()
    <span style="color:#a6e22e">fibonacci</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">quit</span>)
}
</code></pre></div><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">select</span> {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
    <span style="color:#75715e">// 使用 i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span>:
    <span style="color:#75715e">// 从 c 中接收会阻塞时执行
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="等价二叉树">等价二叉树</h3>
<blockquote>
<p><a href="https://tour.go-zh.org/concurrency/8">https://tour.go-zh.org/concurrency/8</a></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;golang.org/x/tour/tree&#34;</span>
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#75715e">// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">Tree</span>, <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">ch</span>)
    }
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Value</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">ch</span>)
    }
}

<span style="color:#75715e">// Same 检测树 t1 和 t2 是否含有相同的值。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Same</span>(<span style="color:#a6e22e">t1</span>, <span style="color:#a6e22e">t2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">Tree</span>) <span style="color:#66d9ef">bool</span> {
    <span style="color:#a6e22e">ch1</span>, <span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>), make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)

    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">t1</span>, <span style="color:#a6e22e">ch1</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">t2</span>, <span style="color:#a6e22e">ch2</span>)

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch2</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">Walk</span>(<span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">ch</span>)
    <span style="color:#75715e">// 使用下面这种方式会出现死锁，为什么？
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// for i := range ch {
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//     fmt.Println(i)
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// }
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
    }

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Same</span>(<span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">1</span>)))
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">Same</span>(<span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">New</span>(<span style="color:#ae81ff">2</span>)))
}
</code></pre></div><h3 id="syncmutex">sync.Mutex</h3>
<p>channel 非常适合在各个 Go 协程间进行通信。</p>
<p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 协程能够访问一个共享的变量，从而避免冲突？</p>
<p>这里涉及的概念叫做 <strong>互斥（mutual exclusion）</strong> ，通常使用 <strong>互斥锁（Mutex）</strong> 这一数据结构来提供这种机制。</p>
<p>Go 标准库中提供了 <code>sync.Mutex</code> 互斥锁类型及其两个方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">Lock</span>
<span style="color:#a6e22e">Unlock</span>
</code></pre></div><p>通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。</p>
<h3 id="web-爬虫">Web 爬虫</h3>
<blockquote>
<p><a href="https://tour.go-zh.org/concurrency/10">https://tour.go-zh.org/concurrency/10</a></p>
</blockquote>
<p>在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。</p>
<p>修改 <code>Crawl</code> 函数来并行地抓取 URL，并且保证不重复。</p>
<p>提示：你可以用一个 <code>map</code> 来缓存已经获取的 URL，但是要注意 <code>map</code> 本身并不是并发安全的！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Fetcher</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#75715e">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">body</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">urls</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
}

<span style="color:#75715e">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Crawl</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">depth</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>) {
    <span style="color:#75715e">// TODO: 并行的抓取 URL。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// TODO: 不重复抓取页面。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">depth</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">urls</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fetcher</span>.<span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;found: %s %q\n&#34;</span>, <span style="color:#a6e22e">url</span>, <span style="color:#a6e22e">body</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
        <span style="color:#a6e22e">Crawl</span>(<span style="color:#a6e22e">u</span>, <span style="color:#a6e22e">depth</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">fetcher</span>)
    }
    <span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">// 序列化爬取
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Serial</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>, <span style="color:#a6e22e">fetched</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fetched</span>[<span style="color:#a6e22e">url</span>] {
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">fetched</span>[<span style="color:#a6e22e">url</span>] = <span style="color:#66d9ef">true</span>
    <span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">urls</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fetcher</span>.<span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;found: %s %q\n&#34;</span>, <span style="color:#a6e22e">url</span>, <span style="color:#a6e22e">body</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
        <span style="color:#a6e22e">Serial</span>(<span style="color:#a6e22e">u</span>, <span style="color:#a6e22e">fetcher</span>, <span style="color:#a6e22e">fetched</span>)
    }
    <span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">// 分布式爬取，使用共享数据+互斥锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fetchState</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
    <span style="color:#a6e22e">fetched</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ConcurrentMutex</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fetchState</span>) {
    <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
    <span style="color:#a6e22e">already</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">fetched</span>[<span style="color:#a6e22e">url</span>]
    <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">fetched</span>[<span style="color:#a6e22e">url</span>] = <span style="color:#66d9ef">true</span>
    <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">already</span> {
        <span style="color:#66d9ef">return</span>
    }

    <span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">urls</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fetcher</span>.<span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;found: %s %q\n&#34;</span>, <span style="color:#a6e22e">url</span>, <span style="color:#a6e22e">body</span>)
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
        <span style="color:#a6e22e">done</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">u</span> <span style="color:#66d9ef">string</span>) {
            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">done</span>.<span style="color:#a6e22e">Done</span>()
            <span style="color:#a6e22e">ConcurrentMutex</span>(<span style="color:#a6e22e">u</span>, <span style="color:#a6e22e">fetcher</span>, <span style="color:#a6e22e">f</span>)
        }(<span style="color:#a6e22e">u</span>)
    }
    <span style="color:#a6e22e">done</span>.<span style="color:#a6e22e">Wait</span>()

    <span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">// 分布式爬取，使用 channel 进行主从通信
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>) {
    <span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">urls</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fetcher</span>.<span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
        <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> []<span style="color:#66d9ef">string</span>{}
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;found: %s %q\n&#34;</span>, <span style="color:#a6e22e">url</span>, <span style="color:#a6e22e">body</span>)
        <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">urls</span>
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">master</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>) {
    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#a6e22e">fetched</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">urls</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">urls</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fetched</span>[<span style="color:#a6e22e">u</span>] <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span> {
                <span style="color:#a6e22e">fetched</span>[<span style="color:#a6e22e">u</span>] = <span style="color:#66d9ef">true</span>
                <span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">u</span>, <span style="color:#a6e22e">ch</span>, <span style="color:#a6e22e">fetcher</span>)
            }
        }
        <span style="color:#75715e">// ch 中的数据都为空字符串或者都为 true，就不会进入内层 for 循环，n = 1
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// n -= 1，然后 n = 0 就能够作为循环退出的条件了
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">n</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
            <span style="color:#66d9ef">break</span>
        }
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ConcurrentChannel</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fetcher</span> <span style="color:#a6e22e">Fetcher</span>) {
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>)
    <span style="color:#75715e">// 初始化
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> []<span style="color:#66d9ef">string</span>{<span style="color:#a6e22e">url</span>}
    }()

    <span style="color:#a6e22e">master</span>(<span style="color:#a6e22e">ch</span>, <span style="color:#a6e22e">fetcher</span>)
}


<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Crawl...&#34;</span>)
    <span style="color:#a6e22e">Crawl</span>(<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>, <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">fetcher</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Serial...&#34;</span>)
    <span style="color:#a6e22e">fetched</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)
    <span style="color:#a6e22e">Serial</span>(<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>, <span style="color:#a6e22e">fetcher</span>, <span style="color:#a6e22e">fetched</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;ConcurrentMutex...&#34;</span>)
    <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fetchState</span>{<span style="color:#a6e22e">fetched</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)}
    <span style="color:#a6e22e">ConcurrentMutex</span>(<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>, <span style="color:#a6e22e">fetcher</span>, <span style="color:#a6e22e">f</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;ConcurrentChannel...&#34;</span>)
    <span style="color:#a6e22e">ConcurrentChannel</span>(<span style="color:#e6db74">&#34;https://golang.org/&#34;</span>, <span style="color:#a6e22e">fetcher</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
}

<span style="color:#75715e">// fakeFetcher 是返回若干结果的 Fetcher。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeFetcher</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">fakeResult</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeResult</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">body</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">urls</span> []<span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">fakeFetcher</span>) <span style="color:#a6e22e">Fetch</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">string</span>, []<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>[<span style="color:#a6e22e">url</span>]; <span style="color:#a6e22e">ok</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">body</span>, <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">urls</span>, <span style="color:#66d9ef">nil</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;not found: %s&#34;</span>, <span style="color:#a6e22e">url</span>)
}

<span style="color:#75715e">// fetcher 是填充后的 fakeFetcher。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fetcher</span> = <span style="color:#a6e22e">fakeFetcher</span>{
    <span style="color:#e6db74">&#34;https://golang.org/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
        <span style="color:#e6db74">&#34;The Go Programming Language&#34;</span>,
        []<span style="color:#66d9ef">string</span>{
            <span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>,
            <span style="color:#e6db74">&#34;https://golang.org/cmd/&#34;</span>,
        },
    },
    <span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
        <span style="color:#e6db74">&#34;Packages&#34;</span>,
        []<span style="color:#66d9ef">string</span>{
            <span style="color:#e6db74">&#34;https://golang.org/&#34;</span>,
            <span style="color:#e6db74">&#34;https://golang.org/cmd/&#34;</span>,
            <span style="color:#e6db74">&#34;https://golang.org/pkg/fmt/&#34;</span>,
            <span style="color:#e6db74">&#34;https://golang.org/pkg/os/&#34;</span>,
        },
    },
    <span style="color:#e6db74">&#34;https://golang.org/pkg/fmt/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
        <span style="color:#e6db74">&#34;Package fmt&#34;</span>,
        []<span style="color:#66d9ef">string</span>{
            <span style="color:#e6db74">&#34;https://golang.org/&#34;</span>,
            <span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>,
        },
    },
    <span style="color:#e6db74">&#34;https://golang.org/pkg/os/&#34;</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeResult</span>{
        <span style="color:#e6db74">&#34;Package os&#34;</span>,
        []<span style="color:#66d9ef">string</span>{
            <span style="color:#e6db74">&#34;https://golang.org/&#34;</span>,
            <span style="color:#e6db74">&#34;https://golang.org/pkg/&#34;</span>,
        },
    },
}
</code></pre></div><h2 id="版权声明">版权声明</h2>
<p>本作品采用<a href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接。</p>

    </div>
  </article>

  
<section class="comments">
<script src="https://utteranc.es/client.js"
        repo="qiaoin/hugo-blog-comments"
        issue-term="og:title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</section>



</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="https://qiaoin.github.io">在桥边</a> © 2016 - 2021
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/awk.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/bash.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/c.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/c&#43;&#43;.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/cmake.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/go.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/html.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/java.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/javascript.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/rust.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/typescript.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EBLEJGMMQV"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-EBLEJGMMQV', { 'anonymize_ip': false });
}
</script>

  </body>
</html>


<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.82.0" />


<title>来，我们写一个 Daemon（守护进程），不是 Demo - 在桥边</title>
<meta property="og:title" content="来，我们写一个 Daemon（守护进程），不是 Demo - 在桥边">


  <link href='https://qiaoin.github.io/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/monokai.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/re-learning-cs/">重学基础</a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/qiaoin">GitHub</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">10 min read</span>
    

    <h1 class="article-title">来，我们写一个 Daemon（守护进程），不是 Demo</h1>

    
    <span class="article-date">2021-04-26</span>
    

    <div class="article-content">
      <hr>
<div class="toc">
    <details>
        <summary>Table of contents</summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#什么是-daemon">什么是 Daemon？</a></li>
    <li><a href="#什么时候需要写一个-daemon">什么时候需要写一个 Daemon</a></li>
    <li><a href="#daemon-的特征">Daemon 的特征</a></li>
    <li><a href="#会话进程组控制终端">会话、进程组、控制终端</a></li>
    <li><a href="#nohup--运行起来的是-daemon-吗">nohup &amp; 运行起来的是 Daemon 吗？</a></li>
    <li><a href="#daemon-编程最佳实践">Daemon 编程最佳实践</a></li>
    <li><a href="#单实例-daemon">单实例 Daemon</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#画图工具">画图工具</a></li>
    <li><a href="#版权声明">版权声明</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
    </details>
</div>
<hr>
<h2 id="什么是-daemon">什么是 Daemon？</h2>
<p>守护进程（daemon）是生存期长的一种进程。它们常常在系统引导装入时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以说它们是在后台运行的。Unix 中有很多守护进程，它们执行系统任务。</p>
<h2 id="什么时候需要写一个-daemon">什么时候需要写一个 Daemon</h2>
<p>日常工作中，我们经常需要写一个脚本来处理一些事情，例如：</p>
<ul>
<li>消息推送；</li>
<li>与商户系统进行对账；</li>
<li>数据迁移；</li>
<li>商户后台系统健康度监测；</li>
<li>其他的一些处理任务，etc……</li>
</ul>
<p>其实说是 Daemon，但这里更多的案例是定时任务，使用 <code>crontab</code> 定时拉起 Daemon 进行任务处理。</p>
<p>一般我们就是撸起袖子开干：</p>
<ol>
<li>使用 Cpp 写一个 main，对文件中的每一行进行处理</li>
<li>编写 Shell 脚本
<ol>
<li>SED 分割文件</li>
<li>for 循环 main 二进制，拉起的进程数等于分割的文件数</li>
<li>AWK 处理输出日志，进行后续处理</li>
</ol>
</li>
</ol>
<p>第 2 步中的 Shell 文件，使用 <code>nohup ./xxx.sh &amp;</code> 进行执行</p>
<ul>
<li><code>&amp;</code> 通过一个子进程（作为当前 Shell 的子进程）在后台运行 <code>./xxx.sh</code>，「后台任务 background job」
<ul>
<li>终端执行了一次 <code>fork</code>，让待执行的命令作为子进程运行，不阻塞终端窗口输入；此后台任务没有获得控制终端，不能接收输入（但是可以往终端输出信息）</li>
</ul>
</li>
<li><code>nohup</code> 设置忽略 <code>SIGHUP</code> 信号</li>
</ul>
<p><code>nohup</code> 和 <code>&amp;</code> 一起作用，让命令在后台执行。我们要问，这样运行起来的是 Daemon 守护进程吗？一起来看看 Daemon 的特征吧。</p>
<h2 id="daemon-的特征">Daemon 的特征</h2>
<p>我们先看一下常用的系统守护进程：<code>ps -axj</code>，<code>-a</code> 显示由其他用户所拥有的进程的状态，<code>-x</code> 显示没有控制终端的进程状态，<code>-j</code> 显示与作业有关的信息：会话 ID、进程组 ID、控制终端以及终端进程组 ID。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> $ ps -axj
 PPID   PID  PGID   SID   TTY   UID   TIME   COMMAND
    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">1</span>     <span style="color:#ae81ff">1</span>     <span style="color:#ae81ff">1</span>   ?       <span style="color:#ae81ff">0</span>  40:01   /usr/lib/systemd/systemd --switched-root --system --deserialize <span style="color:#ae81ff">22</span>
    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">2</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:02   <span style="color:#f92672">[</span>kthreadd<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>     <span style="color:#ae81ff">3</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:10   <span style="color:#f92672">[</span>ksoftirqd/0<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>     <span style="color:#ae81ff">5</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>kworker/0:0H<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>     <span style="color:#ae81ff">7</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:31   <span style="color:#f92672">[</span>migration/0<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>     <span style="color:#ae81ff">8</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>rcu_bh<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>     <span style="color:#ae81ff">9</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span> 121:34   <span style="color:#f92672">[</span>rcu_sched<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">48</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>netns<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">52</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>bioset<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">53</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>crypto<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">75</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>cciss_scan<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">76</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>nvme<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">97</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>ipv6_addrconf<span style="color:#f92672">]</span>
    <span style="color:#ae81ff">2</span>   <span style="color:#ae81ff">155</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   ?       <span style="color:#ae81ff">0</span>   0:00   <span style="color:#f92672">[</span>kauditd<span style="color:#f92672">]</span>
</code></pre></div><p>按照顺序，各列标题分别对应为：父进程 ID、进程 ID、进程组 ID、会话 ID、终端名称、用户 ID、命令字符串。</p>
<p>父进程 ID 为 0 的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动（<code>init</code> 是个例外，它是一个由内核在引导装入时启动的用户层次的命令）。内核进程是特殊的，通常存在于系统的整个生命周期中。它们以 root 特权运行，无控制终端，无命令行。</p>
<p>进程 1 通常是 <code>init</code>（目前打印出来的是 <code>systemd</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>），它是一个系统守护进程，除了其他工作外，主要负责启动各运行层次特定的系统服务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。</p>
<p>注意，大多数守护进程都是以 root 特权运行。所有的守护进程都没有控制终端，其终端名设置为问号。内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了 <code>setsid</code> 的结果。大多数用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程（<code>rsyslogd</code> 是一个例外）。最后，所有的用户层守护进程的父进程都是 <code>init</code> 进程。</p>
<h2 id="会话进程组控制终端">会话、进程组、控制终端</h2>
<p>每个进程除了有一个进程 ID 外，还属于一个进程组。进程组是一个或多个进程的集合。进程组之于进程，类似于文件夹之于文件，主要是为了方便管理，同一个进程组中的各进程接受来自同一个终端的各种信号。</p>
<p>每个进程组有一个唯一的进程组 ID。</p>
<p>每个进程组有一个组长进程（leader process）。组长进程的进程组 ID 等于其进程 ID。</p>
<p>-&gt; 一个进程组的进程组 ID == 该进程组组长进程的进程 ID</p>
<p>会话（session）是一个或多个进程组的集合，被分为一个前台进程组（foreground process group）以及一个或多个后台进程组（background process group）。</p>
<p>一个会话可以有一个控制终端（controlling terminal），通常是终端设备（在终端登录情况下）或伪终端设备（在网络登录情况下）。和控制终端建立连接的会话首进程被称为控制进程（controlling process）。通常，我们不必担心控制状态，登录时，将自动建立控制终端。</p>
<p>进程组、会话和控制终端的关系，如下图所示。</p>
<p><img src="images/session-process-group.png" alt="进程组、会话和控制终端的关系"></p>
<p>图 1 - 进程组、会话和控制终端的关系</p>
<h2 id="nohup--运行起来的是-daemon-吗">nohup &amp; 运行起来的是 Daemon 吗？</h2>
<p>现在，我们可以回答这个问题了，<code>nohup ./xxx.sh &amp;</code> 运行起来的后台作业（background job）与 Daemon，二者还是有区别的，虽然后台作业可以在一定程度上不受控制终端约束，可达到控制终端退出后自己仍然运行的目的，但是还有几个问题：</p>
<ol>
<li>关闭终端后会发送 <code>SIGHUP</code> 信号给会话首进程（session leader），会话首进程在收到后会进行信号处理，其处理方式依赖于系统实现和系统配置，可能导致后台作业同步退出。</li>
<li>控制终端退出了，但后台作业还是可以往终端输出信息；而守护进程是无控制终端的。</li>
<li>Unix/Linux 的进程会继承父进程的很多特性，例如文件掩码（mask）、当前工作目录、已打开的文件句柄、信号处理等，可能导致进程本身和环境依赖相关，应该重置。</li>
</ol>
<p>那写 Daemon 的正确姿势是什么样的呢？</p>
<h2 id="daemon-编程最佳实践">Daemon 编程最佳实践</h2>
<p>在大多数 Unix 系统中，守护进程是一直存在的。为了初始化我们自己的进程，使之作为守护进程运行，需要一些审慎的思索。在编写守护进程时需遵循一些基本规则，以防止产生不必要的交互作用。</p>
<p>1、调用 <code>umask</code><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 将文件模式创建屏蔽字设置为一个已知值（通常是 0）。子进程继承得来的父进程的文件模式创建屏蔽字，可能会被设置为拒绝某些权限。因此，将文件模式创建屏蔽字设置为 0，可以大大增强子进程的灵活性。</p>
<p><img src="images/umask.png" alt="umask"></p>
<p>图 2 - umask(0)</p>
<p>2、调用 <code>fork</code>，然后父进程 <code>exit</code>。父进程终止会让 Shell 认为这个命令已经执行完毕，同时虽然子进程继承了父进程的进程组 ID，但其进程 ID 是新分配的，二者不可能相等，这就保证了子进程不是一个进程组的组长进程（为接下来第 3 步调用 <code>setsid</code> 做好准备）。</p>
<p>在调用了 <code>fork</code> 函数后，子进程全盘拷贝了父进程的会话、进程组、控制终端等，虽然父进程退出了，但会话、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来。接下来，</p>
<p>3、调用 <code>setsid</code><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> 创建一个新会话。针对会话、进程组、控制终端执行三个步骤：</p>
<ul>
<li>
<p>（i）摆脱原会话的控制：该进程成为新会话的首进程（session leader，会话首进程是创建该会话的进程），此时，该进程是新会话中的唯一进程；</p>
</li>
<li>
<p>（ii）摆脱原进程组的控制：该进程成为一个新进程组的组长进程。新建成进程组 ID 是该调用进程的进程 ID；</p>
</li>
<li>
<p>（iii）摆脱控制终端：该进程没有控制终端。如果在调用 <code>setsid</code> 之前该进程有一个控制终端，那么与该终端的联系被解除。</p>
</li>
</ul>
<p>4、再次调用 <code>fork</code>，父进程 <code>exit</code>，继续使用子进程中的守护进程。这样就保证了该守护进程不会是会话首进程，可以防止它取得控制终端（因为作为无控制终端的进程组的组长进程，它可以重新申请打开一个控制终端）。</p>
<p>5、将当前工作目录更改为根目录 <code>chdir(&quot;/&quot;)</code>。从父进程继承过来的当前目录可能在一个挂载的文件系统中，以防该文件系统在守护进程的执行期间不能被卸载。</p>
<p>6、关闭不再需要的文件描述符，使得守护进程不再持有从其父进程继承而来的任何文件描述符。</p>
<p>7、注册信号处理函数<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>。</p>
<p>8、执行处理任务。</p>
<p><a href="https://www.man7.org/tlpi/">The Linux Programming Interface</a> 提供了一个创建 Daemon 守护进程的代码片段 <a href="https://www.man7.org/tlpi/code/online/dist/daemons/become_daemon.c.html">become_daemon.c<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></a>，当然 Unix 环境高级编程第 13 章也给到了详细的<a href="http://www.apuebook.com/src.3e.tar.gz">代码示例<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></a>，可以下载后进入 <code>daemons</code> 目录查看。</p>
<p><img src="images/daemon-best-practice.png" alt="Daemon 编程最佳实践"></p>
<p>图 3 - Daemon 编程最佳实践</p>
<h2 id="单实例-daemon">单实例 Daemon</h2>
<p>为了正常运行，某些守护进程会实现为，在任一时刻只运行该守护进程的一个副本。例如，对 <code>cron</code> 守护进程而言，如果同时有多个实例运行，那么每个副本都可能试图开始某个预定的操作，于是造成该操作的重复执行，这很可能导致错误。</p>
<p>文件和记录锁机制可以保证一个守护进程只有一个副本在运行。如果每一个守护进程创建一个有固定名字的文件，并在该文件的整体上加一把锁，那么只允许创建一把这样的写锁。在此之后创建写锁的所有尝试都会失败，这向后续守护进程的副本指明已有一个副本正在运行。</p>
<p>文件和记录锁<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>提供了一种方便的互斥机制。如果守护进程在一个文件的整体上得到一把写锁，那么在该守护进程终止时，这把锁将被自动删除。</p>
<p><a href="https://www.man7.org/tlpi/">The Linux Programming Interface</a> 提供了一个创建 PID 文件代码片段 <a href="https://www.man7.org/tlpi/code/online/dist/filelock/create_pid_file.c.html">create_pid_file.c<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e">struct flock {
</span><span style="color:#75715e">    off_t       l_start;    // starting offset
</span><span style="color:#75715e">    off_t       l_len;      // len = 0 means until end of file
</span><span style="color:#75715e">    pid_t       l_pid;      // lock owner
</span><span style="color:#75715e">    short       l_type;     // lock type: read/write, etc.
</span><span style="color:#75715e">    short       l_whence;   // type of l_start
</span><span style="color:#75715e">};
</span><span style="color:#75715e">*/</span>

<span style="color:#75715e">/* Lock a file region using nonblocking F_SETLK */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lockFile</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">int</span> whence, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> len) {
  <span style="color:#66d9ef">struct</span> flock fl;

  fl.l_type <span style="color:#f92672">=</span> type;
  fl.l_whence <span style="color:#f92672">=</span> whence;
  fl.l_start <span style="color:#f92672">=</span> start;
  fl.l_len <span style="color:#f92672">=</span> len;

  <span style="color:#66d9ef">return</span> fcntl(fd, F_SETLK, <span style="color:#f92672">&amp;</span>fl);
}

<span style="color:#75715e">#define BUF_SIZE 100 </span><span style="color:#75715e">/* Large enough to hold maximum PID as string */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">createPidFile</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> progName, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pidFile, <span style="color:#66d9ef">int</span> flags) {
  <span style="color:#66d9ef">int</span> fd;
  <span style="color:#66d9ef">char</span> buf[BUF_SIZE];

  fd <span style="color:#f92672">=</span> open(pidFile, O_RDWR <span style="color:#f92672">|</span> O_CREAT, <span style="color:#ae81ff">0666</span>);
  <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    errExit(<span style="color:#e6db74">&#34;Could not open PID file %s&#34;</span>, pidFile);
  }

  <span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> CPF_CLOEXEC) {
    <span style="color:#75715e">/* Set the close-on-exec file descriptor flag */</span>
    flags <span style="color:#f92672">=</span> fcntl(fd, F_GETFD); <span style="color:#75715e">/* Fetch flags */</span>
    <span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      errExit(<span style="color:#e6db74">&#34;Could not get flags for PID file %s&#34;</span>, pidFile);
    }

    flags <span style="color:#f92672">|=</span> FD_CLOEXEC; <span style="color:#75715e">/* Turn on FD_CLOEXEC */</span>

    <span style="color:#66d9ef">if</span> (fcntl(fd, F_SETFD, flags) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      <span style="color:#75715e">/* Update flags */</span>
      errExit(<span style="color:#e6db74">&#34;Could not set flags for PID file %s&#34;</span>, pidFile);
    }
  }

  <span style="color:#66d9ef">if</span> (lockFile(fd, F_WRLCK, SEEK_SET, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">if</span> (errno <span style="color:#f92672">==</span> EAGAIN <span style="color:#f92672">||</span> errno <span style="color:#f92672">==</span> EACCES) {
      fatal(<span style="color:#e6db74">&#34;PID file &#39;%s&#39; is locked; probably &#39;%s&#39; is already running&#34;</span>, pidFile, progName);
    } <span style="color:#66d9ef">else</span> {
      errExit(<span style="color:#e6db74">&#34;Unable to lock PID file &#39;%s&#39;&#34;</span>, pidFile);
    }
  }

  <span style="color:#66d9ef">if</span> (ftruncate(fd, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    errExit(<span style="color:#e6db74">&#34;Could not truncate PID file &#39;%s&#39;&#34;</span>, pidFile);
  }

  snprintf(buf, BUF_SIZE, <span style="color:#e6db74">&#34;%ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">long</span>)getpid());
  <span style="color:#66d9ef">if</span> (write(fd, buf, strlen(buf)) <span style="color:#f92672">!=</span> strlen(buf)) {
    fatal(<span style="color:#e6db74">&#34;Writing to PID file &#39;%s&#39;&#34;</span>, pidFile);
  }

  <span style="color:#66d9ef">return</span> fd;
}
</code></pre></div><p>1、<code>open(pidfile, O_RDWR | O_CREAT)</code> 打开或新建一个文件，返回对应的文件描述符 fd。</p>
<p>2、<code>flags |= FD_CLOEXEC</code> 对所有被执行程序不需要的文件描述符设置执行时关闭（<code>close-on-exec</code>）标识；</p>
<p>3、<code>fcntl(fd, F_SETLK, &amp;fl)</code> 对 pidFile 文件加锁（排它锁）</p>
<ul>
<li><code>l_len = 0</code> 表示锁的范围可以扩展到最大可能偏移量。这意味着不管向该文件中追加写了多少数据，它们都可以处于锁的范围内，而且起始位置可以是文件中的任意一个位置</li>
<li>为了对整个文件进行加锁，设置 <code>l_start</code> 和 <code>l_whence</code> 指向文件的起始位置，并且指定长度（<code>l_len</code>）为 0</li>
<li><code>l_type</code> 可以表示三种类型：<code>F_RDLCK</code>（共享性读锁）、<code>F_WRLCK</code>（独占性写锁）或 <code>F_UNLCK</code>（解锁一个区域）</li>
<li>两种类型的锁：共享性读锁（<code>F_RDLCK</code>）和独占性写锁（<code>F_WRLCK</code>），基本规则是：任意多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定的字节上只能有一个进程有一把独占锁。进一步解释，如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁；如果在一个字节上已经有一把独占性写锁，则不能在对它加任何读锁。下图表示了这些兼容性规则：</li>
</ul>
<p><img src="images/fcntl-setlk.png" alt="不同类型锁彼此之间的兼容性"></p>
<p>图 4 - 不同类型锁彼此之间的兼容性</p>
<p><!-- raw HTML omitted --></p>
<ul>
<li><code>F_SETLK</code> 如果我们试图获取一把读锁或写锁，而上述的兼容性规则阻止系统给我们这把锁，那么 <code>fcntl</code> 会立即出错返回，此时 <code>errno</code> 设置为 <code>EACCES</code> 或 <code>EAGAIN</code></li>
</ul>
<p>4、<code>ftruncate(fd, 0)</code> 将文件长度截断为 0。其原因是之前的守护进程实例的进程 ID 字符串可能长于调用此函数的当前进程 ID 字符串。例如，之前的守护进程的进程 ID 是 12345，当前实例的进程 ID 是 9999，那么将此进程 ID 写入文件后，在文件中留下的是 99995。将文件长度截断为 0 就解决了此问题。</p>
<p>5、<code>write(fd, strPid, strlen(strPid)</code> 将进程 pid 写入文件。后续当有实例启动执行时，会试图调用 <code>fcnt(fd, F_SETLK, &amp;fl)</code> 对 pidFile 进行加锁，会执行失败（由于已经有一个进程持有了排它锁），表示已有副本正在运行。</p>
<h2 id="总结">总结</h2>
<p>至此，我们从 Daemon 的特征入手，讨论了其与 <code>nohup + &amp;</code> 启动后台作业的区别，进而介绍构建 Daemon 的最佳实践，以及如何保证 Daemon 的单实例执行。读者可以从本文中给到的 Demo 入手，运行起来。</p>
<h2 id="画图工具">画图工具</h2>
<p>文中的图片使用 <a href="https://excalidraw.com/">excalidraw</a> 绘制</p>
<h2 id="版权声明">版权声明</h2>
<p>本作品采用<a href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接。</p>
<h2 id="references">References</h2>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>LINUX PID 1 和 SYSTEMD <a href="https://coolshell.cn/articles/17998.html">https://coolshell.cn/articles/17998.html</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>umask <a href="https://man7.org/linux/man-pages/man2/umask.2.html">https://man7.org/linux/man-pages/man2/umask.2.html</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>setsid <a href="https://man7.org/linux/man-pages/man2/setsid.2.html">https://man7.org/linux/man-pages/man2/setsid.2.html</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>Unix 环境高级编程 第 10 章 - 信号 <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p><a href="https://book.douban.com/subject/25809330/">Linux/UNIX系统编程手册</a> <a href="https://www.man7.org/tlpi/code/online/dist/daemons/become_daemon.c.html">https://www.man7.org/tlpi/code/online/dist/daemons/become_daemon.c.html</a> <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>APUE Source Code <a href="http://www.apuebook.com/code3e.html">http://www.apuebook.com/code3e.html</a> <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>Unix 环境高级编程 第 14 章 - 高级I/O - 14.3 记录锁 <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p>Linux/UNIX系统编程手册 <a href="https://www.man7.org/tlpi/code/online/dist/filelock/create_pid_file.c.html">https://www.man7.org/tlpi/code/online/dist/filelock/create_pid_file.c.html</a> <a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </div>
  </article>

  
<section class="comments">
<script src="https://utteranc.es/client.js"
        repo="qiaoin/hugo-blog-comments"
        issue-term="og:title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</section>



</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="https://qiaoin.github.io">在桥边</a> © 2016 - 2021
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/awk.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/bash.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/c.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/c&#43;&#43;.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/cmake.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/go.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/html.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/java.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/javascript.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/rust.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/typescript.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EBLEJGMMQV"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-EBLEJGMMQV', { 'anonymize_ip': false });
}
</script>

  </body>
</html>

